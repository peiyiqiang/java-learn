[TOC]

### 创建型

创建对象

#### 单例模式

核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。

优点：单例模式只有一个实例，减少系统性能开销。创建对象需要较多的资源时可以使用单例模式。

实现方式：饿汉式、懒汉式、双重检测锁、静态内部类、枚举单例。

应用场景：Windows任务管理器、数据库连接池的设计、操作系统的文件系统、Servlet中的每个Servlet、Spring中每个bean默认是单例的。



#### 工厂模式

##### 简单工厂模式

实现了创建者和调用者的分离。

本质：实例化对象，用工厂方法代替new操作。

缺点：不满足开闭原则（对扩展开放，对修改封闭）；使用工厂方法可解决。

##### 工厂方法模式

解决简单工厂模式不满足开闭原则的缺点。

简单工厂模式只有一个工厂类，而工厂方法模式有一组实现了相同工厂接口的工厂类。



#### 抽象工厂模式

用来生成不同产品族的全部产品（对于增加新的产品，无能为力；支持增加产品族）。

抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。



#### 建造者模式

应用场景：开发中所需要的对象创建时非常复杂，有很多步骤需要处理时。

本质：分离对象子组件的单独构建（由Builder负责）和装配（由Director负责），从而构造出复杂的对象；实现了构建和装配的解耦。

角色：构建者、装配者、构建者实现类、装配者实现类



#### 原型模式

通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式，提高效率  。

克隆类似与new，但不同于new。

经常与工厂模式结合使用，在工厂里面使用clone生成新对象。

应用：Spring中bean的创建（单例和原型）。



### 结构型

从程序的结构上实现松耦合，从而扩大整体的类结构，用来解决更大的问题

#### 适配器模式

将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

角色：目标接口Target、需要适配的类Adaptee、适配器Adapter。

应用场景：旧系统的改造升级、Java的IO流（InputStreamReader将InputStream转为Reader）。



#### 桥接模式

处理多继承结构、多维度变化的场景，将各个维度设计成独立的继承结构，在抽象层简历关联，使各个维度可以独立地扩展。

角色：

- Abstraction：抽象化角色，定义出该角色的行为，同时保存一个对实现化角色的引用
- RefinedAbstraction：修正抽象化角色，引用实现化角色对抽象化角色进行修正
- Implementor：实现化角色，它是接口或者抽象类，定义角色必需的行为和属性
- ConcreteImplementor：具体实现化角色，实现接口或抽象类定义的方法或属性



#### 装饰模式

动态地为一个对象增加新的功能。

装饰模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。

角色：

- Component：抽象构件
- ConcreteComponent：具体构件
- Decorator：装饰角色
- ConcreteDecorator：具体装饰角色

使用场景：IO流

与桥接模式区别：两个模式都是为了解决过多子类对象问题。但他们的诱因不一样，桥接模式是对象自身现有机制沿着多个维度变化，装饰模式是为了增加新的功能。



#### 组合模式

把部分和整体的关系用树形结构表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。

角色：

- 抽象构件角色（Component）：定义了叶子和容器构件的共同点
- 叶子构件角色（Leaf）：无子节点
- 容器构件角色（Composite）：有容器特征，可以包含子节点

应用场景：操作系统中的资源管理器、XML文件解析、Junit单元测试框架



#### 外观模式

为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用

应用场景：各种工具类



#### 享元模式

内存属于稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存。

享元模式以共享的方式高效地支持大量细粒度对象的重用。

享元对象能做到共享的关键是区分了内部状态和外部状态：

- 内部状态：可以共享，不会随环境变化而变化
- 外部状态：不可以共享，会随环境变化而变化

角色：

- FlyweightFactory享元工厂类：创建并管理享元对象，享元池一般设计成键值对。
- Flyweight抽象享元类：通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。
- ConcreteFlyWeight具体享元类：为内部状态提供成员变量进行存储
- UnsharedConcreteFlyWeight非共享享元类：不能被共享的子类可以设计为非共享享元类

应用场景：线程池、数据库连接池、String类

优点：

- 极大减少内存中对象的数量
- 相同或相似对象内存中只存一份，极大的节约资源，提高系统性能
- 外部状态相对独立，不影响内部状态

缺点：

- 模式较复杂，使程序逻辑复杂化
- 为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间边长，用时间换取了空间



#### 代理模式

##### 静态代理

核心作用：通过代理，控制对对象的访问；AOP的核心实现机制。

角色：抽象角色、真实角色、代理角色

应用：多线程的Runnable。

##### 动态代理

优点：抽象角色（接口）中声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一地处理众多地方法。



### 行为型

关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。

#### 模板方法模式

多态的应用

模版方法模式定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现

何时使用：实现一个算法时，整体步骤很固定，但是某些部分易变

应用：  
- Junit单元测试
- servlet中关于doGet()/doPost()方法的调用



#### 命令模式

将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。

角色：

- Command抽象命令类
- ConcreteCommand具体命令类
- Invoker调用者/请求者
- Receiver接收者

应用场景：数据库事务机制的底层实现、命令的撤销和恢复



#### 迭代器模式

提供一种可以遍历聚合对象的方式（聚合对象：存储数据、迭代器：遍历数据）

应用场景：JDK内置的迭代器（List/Set）



#### 观察者模式

应用场景：

- Servlet中监听器的实现
- Android中的广播机制



#### 中介者模式

如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系及其复杂。我们可以引入一个中介者对象，使各个同事对象只跟中介者对象打交道，将复杂的网络结构化解为星形结构。

应用场景：MVC模式、Java反射中的invoke()



#### 备忘录模式

保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态

角色：

- 源发器类Originator
- 备忘录类Memento
- 负责人类CareTaker

应用场景：数据库事务的回滚操作、命令的撤销操作



#### 状态模式

用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题

角色：

- Context环境类：环境类中维护一个State对象，定义了当前的状态
- State抽象状态类
- ConcreteState具体状态类：每一个类封装了一个状态对应的行为

应用场景：

- 银行系统中帐号状态的管理
- 线程对象各状态之间的切换



#### 策略模式

策略模式对应于解决某一个问题的算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便地更换算法或者新增算法。并且可以由客户端决定调用哪个方法。

本质：分离算法，选择实现

应用：

- JavaSE的GUI编程中，布局管理
- Spring框架中，Resource接口，资源访问策略
- javax.servlet.http.HttpServlet#service()



#### 职责链模式

将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象。

应用场景：Java中的异常机制



#### 解释器模式

一种不常用的设计模式

应用场景：EL表达式的处理、正则表达式解释器、SQL语法解释器、数学表达式解析器



#### 访问者模式

对于存储在一个集合中的对象，他们可能具有不同的类型（即使有一个公共的接口），对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同。

应用场景：XML文档解析器设计、编译器的设计



### 设计原则

开闭原则（Open Closed Principle，OCP）

依赖倒转原则（Dependency Inversion Principle，DIP）

迪米特法则（Law of Demeter，LoD）

单一职责原则（Single Responsibility Principle）